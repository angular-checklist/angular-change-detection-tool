{"version":3,"file":"tree-traversal.js","sourceRoot":"","sources":["../src/tree-traversal.ts"],"names":[],"mappings":";;AAAA,qDAU8B;AAC9B,+BAA+D;AAC/D,yDAI6B;AAC7B,2BAA6B;AAC7B,yCAAkD;AAElD,SAAgB,wBAAwB,CAAC,EAiBxC;QAhBA,gBAAK,EACL,cAAI,EACJ,gDAAqB,EACrB,sCAAgB,EAChB,2BAA2B,EAA3B,gDAA2B;IAa3B,KACC,IAAI,OAAO,GACV,qBAAqB,KAAK,SAAS;QAClC,CAAC,CAAC,qBAAqB;QACvB,CAAC,CAAC,KAAK,CAAC,yBAAU,CAAC,EACrB,OAAO,KAAK,IAAI,EAChB,OAAO,GAAG,OAAO,CAAC,mBAAI,CAAC,EACtB;QACD,IAAI,OAAO,CAAC,2BAAY,CAAC,KAAK,CAAC,CAAC,IAAI,mBAAY,CAAC,OAAO,CAAC,EAAE;YAC1D,KAAK,IAAI,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,sCAAuB,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpG,IAAM,eAAe,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBACnC,IAAI,CACH,eAAe,EACf,CAAC,IAAI,OAAO,CAAC,MAAM,EACnB,CAAC,EACD,OAAO,CAAC,mBAAI,CAAC,CACb,CAAC;gBACF,IAAI,mBAAmB,EAAE;oBACxB,OAAO,IAAI,CAAC;iBACZ;aACD;YACD,+BAA+B;YAC/B,gBAAgB,GAAG,SAAS,CAAC;SAC7B;KACD;IACD,QAAQ;IACR,6BAA6B;IAC7B,wCAAwC;IACxC,6BAA6B;IAC7B,0BAA0B;IAC1B,qBAAqB;IACrB,2BAA2B;IAC3B,MAAM;IACN,yEAAyE;IACzE,UAAU;IACV,sDAAsD;IACtD,oCAAoC;IACpC,SAAS;IACT,QAAQ;IACR,oDAAoD;IACpD,WAAW;IACX,uBAAuB;IACvB,2CAA2C;IAC3C,SAAS;IACT,oBAAoB;IACpB,QAAQ;IACR,gCAAgC;IAChC,mBAAmB;IACnB,OAAO;IACP,MAAM;IACN,KAAK;IACL,IAAI;IACJ,OAAO,KAAK,CAAC;AACd,CAAC;AAvED,4DAuEC;AAED,SAAgB,mBAAmB,CAAC,EAQnC;QAPA,gBAAK,EACL,cAAI,EACJ,4CAAmB;IAMnB,IAAM,KAAK,GAAG,KAAK,CAAC,oBAAK,CAAC,CAAC;IAC3B,IAAI,KAAK,CAAC,UAAU,IAAI,IAAI,EAAE;QAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACjD,IAAM,UAAU,GAAG,8BAAuB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;YACvE,IAAI,CAAC,UAAU,CAAC,CAAC;YACjB,IAAI,mBAAmB,EAAE;gBACxB,OAAO,IAAI,CAAC;aACZ;SACD;KACD;IACD,OAAO,KAAK,CAAC;AACd,CAAC;AApBD,kDAoBC;AAED,SAAgB,kCAAkC,CACjD,SAAgB,EAChB,MAAe;IAEf,IAAM,UAAU,GAAG,UAClB,YAA0B,EAC1B,kBAAgC,IAC5B,OAAA,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,EAA9C,CAA8C,CAAC;IACpD,OAAO,uBAAuB,CAAC,UAAU,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;AAC/D,CAAC;AATD,gFASC;AAED,SAAgB,iCAAiC,CAChD,SAAgB,EAChB,MAAe;IAEf,IAAM,YAAY,GAAG,EAAE,CAAC;IACxB,IAAM,UAAU,GAAG,UAAC,YAA0B;QAC7C,OAAA,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC;IAA/B,CAA+B,CAAC;IACjC,OAAO,uBAAuB,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;AAC7E,CAAC;AARD,8EAQC;AAED,IAAM,uBAAuB,GAAG,UAC/B,UAGS,EACT,WAAiB;IAEjB,OAAO,SAAS,YAAY,CAC3B,KAAY,EACZ,MAAe,EACf,kBAAiC;QAEjC,IAAM,YAAY,GAAG,8CAA0B,CAC9C,KAAK,EACL,MAAM,EACN,kBAAkB,CAClB,CAAC;QAEF,oGAAoG;QACpG,IAAI,KAAK,CAAC,mBAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAC3B,wHAAwH;YACxH,UAAU,CAAC,YAAY,EAAE,kBAAkB,CAAC,CAAC;SAC7C;QAED,IAAM,4BAA4B,GAAG,UAAC,YAAmB;YACxD,YAAY,CACX,YAAY,EACZ,KAAK,EACL,YAAY,CAAC,KAAK,CAAC,mBAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,kBAAkB,CAC5D,CAAC;QACH,CAAC,CAAC;QAEF,wBAAwB,CAAC;YACxB,KAAK,OAAA;YACL,IAAI,EAAE,4BAA4B;SAClC,CAAC,CAAC;QAEH,IAAM,uBAAuB,GAAG,UAAC,UAAiB;YACjD,IAAI,CAAC,UAAU,CAAC,mBAAI,CAAC,CAAC,+BAAmB,CAAC,EAAE;gBAC3C,UAAU,CAAC,mBAAI,CAAC,CAAC,+BAAmB,CAAC,GAAG,IAAI,EAAE,CAAC;aAC/C;YACD,YAAY,CACX,UAAU,EACV,KAAK,EACL,YAAY,CAAC,KAAK,CAAC,mBAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,kBAAkB,CAC5D,CAAC;QACH,CAAC,CAAC;QAEF,mBAAmB,CAAC,EAAE,KAAK,OAAA,EAAE,IAAI,EAAE,uBAAuB,EAAE,CAAC,CAAC;QAE9D,IAAI,MAAM,EAAE;YACX,OAAO,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,YAAY,CAAC;SAChD;IACF,CAAC,CAAC;AACH,CAAC,CAAC;AAEF,SAAgB,2BAA2B,CAC1C,iBAAyC;IAEzC,IAAM,YAAY,GAAG,IAAI,GAAG,EAAkC,CAAC;IAE/D,IAAM,QAAQ,GAAG,UAAC,YAAoC;QACrD,YAAY,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;QAClD,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAA,iBAAiB;YAC9C,OAAA,QAAQ,CAAC,iBAAiB,CAAC;QAA3B,CAA2B,CAC3B,CAAC;IACH,CAAC,CAAC;IAEF,QAAQ,CAAC,iBAAiB,CAAC,CAAC;IAE5B,OAAO,YAAY,CAAC;AACrB,CAAC;AAfD,kEAeC;AAED,mIAAmI;AACnI,0CAA0C;AAC1C,SAAgB,aAAa,CAAC,YAA0B;IACvD,IAAI,YAAY,CAAC,KAAK,CAAC,mBAAI,CAAC,EAAE;QAC7B,OAAO,YAAY,CAAC;KACpB;SAAM;QACN,OAAO,aAAa,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;KAC1C;AACF,CAAC;AAND,sCAMC","sourcesContent":["import {\n\tACTIVE_INDEX,\n\tCHILD_HEAD, CONTAINER_HEADER_OFFSET,\n\tHEADER_OFFSET,\n\tHOST,\n\tLContainer,\n\tLView,\n\tNEXT,\n\tTVIEW,\n\tVIEW_REFS\n} from './types/angular_core';\nimport { getComponentViewByIndex, isLContainer } from './util';\nimport {\n\tcreateInitialTreeViewState,\n\tSerializedTreeViewItem,\n\tTreeViewItem\n} from './tree-view-builder';\nimport * as uuid from 'uuid';\nimport { DEVTOOLS_IDENTIFIER } from './constants';\n\nexport function loopDynamicEmbeddedViews({\n\tlView,\n\twork,\n\tnextCurrentLContainer,\n\tnextViewRefIndex,\n\texitLoopPrematurely = false\n}: {\n\tlView: LView;\n\twork: (\n\t\tnextLView: LView,\n\t\tlastViewRef: boolean,\n\t\tcurrentViewRefIndex: number,\n\t\tnextLContainer: LContainer\n\t) => void;\n\tnextCurrentLContainer?: LContainer;\n\tnextViewRefIndex?: number;\n\texitLoopPrematurely?: boolean;\n}) {\n\tfor (\n\t\tlet current: LContainer =\n\t\t\tnextCurrentLContainer !== undefined\n\t\t\t\t? nextCurrentLContainer\n\t\t\t\t: lView[CHILD_HEAD];\n\t\tcurrent !== null;\n\t\tcurrent = current[NEXT]\n\t) {\n\t\tif (current[ACTIVE_INDEX] === -1 && isLContainer(current)) {\n\t\t\tfor (let i = nextViewRefIndex ? nextViewRefIndex : CONTAINER_HEADER_OFFSET; i < current.length; i++) {\n\t\t\t\tconst dynamicViewData = current[i];\n\t\t\t\twork(\n\t\t\t\t\tdynamicViewData,\n\t\t\t\t\ti >= current.length,\n\t\t\t\t\ti,\n\t\t\t\t\tcurrent[NEXT]\n\t\t\t\t);\n\t\t\t\tif (exitLoopPrematurely) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// reset potential old pointers\n\t\t\tnextViewRefIndex = undefined;\n\t\t}\n\t}\n\t// for (\n\t// \tlet current: LContainer =\n\t// \t\tnextCurrentLContainer !== undefined\n\t// \t\t\t? nextCurrentLContainer\n\t// \t\t\t: lView[CHILD_HEAD];\n\t// \tcurrent !== null;\n\t// \tcurrent = current[NEXT]\n\t// ) {\n\t// \tif (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {\n\t// \t\tfor (\n\t// \t\t\tlet i = nextViewRefIndex ? nextViewRefIndex : 0;\n\t// \t\t\ti < current[VIEW_REFS].length;\n\t// \t\t\ti++\n\t// \t\t) {\n\t// \t\t\tconst dynamicViewData = current[VIEW_REFS][i];\n\t// \t\t\twork(\n\t// \t\t\t\tdynamicViewData,\n\t// \t\t\t\ti === current[VIEW_REFS].length - 1,\n\t// \t\t\t\ti,\n\t// \t\t\t\tcurrent[NEXT]\n\t// \t\t\t);\n\t// \t\t\tif (exitLoopPrematurely) {\n\t// \t\t\t\treturn true;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\treturn false;\n}\n\nexport function loopChildComponents({\n\tlView,\n\twork,\n\texitLoopPrematurely\n}: {\n\tlView: LView;\n\twork: (lView: LView) => void;\n\texitLoopPrematurely?: boolean;\n}) {\n\tconst tView = lView[TVIEW];\n\tif (tView.components != null) {\n\t\tfor (let i = 0; i < tView.components.length; i++) {\n\t\t\tconst childLView = getComponentViewByIndex(tView.components[i], lView);\n\t\t\twork(childLView);\n\t\t\tif (exitLoopPrematurely) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function traverseTreeAndCreateTreeStructure(\n\trootLView: LView,\n\tisRoot: boolean\n) {\n\tconst addElement = (\n\t\ttreeViewItem: TreeViewItem,\n\t\tparentTreeViewItem: TreeViewItem\n\t) => parentTreeViewItem.children.push(treeViewItem);\n\treturn traverseTreeToStructure(addElement)(rootLView, isRoot);\n}\n\nexport function traverseTreeAndCreateInstructions(\n\trootLView: LView,\n\tisRoot: boolean\n) {\n\tconst instructions = [];\n\tconst addElement = (treeViewItem: TreeViewItem) =>\n\t\tinstructions.push(treeViewItem);\n\treturn traverseTreeToStructure(addElement, instructions)(rootLView, isRoot);\n}\n\nconst traverseTreeToStructure = (\n\taddElement: (\n\t\ttreeViewItem: TreeViewItem,\n\t\tparentTreeViewItem: TreeViewItem\n\t) => void,\n\taccumulator?: any\n) => {\n\treturn function traverseTree(\n\t\tlView: LView,\n\t\tisRoot: boolean,\n\t\tparentTreeViewItem?: TreeViewItem\n\t) {\n\t\tconst treeViewItem = createInitialTreeViewState(\n\t\t\tlView,\n\t\t\tisRoot,\n\t\t\tparentTreeViewItem\n\t\t);\n\n\t\t// Only when the lView has a host element do we want to add it, otherwise it's a dynamicEmbeddedView\n\t\tif (lView[HOST] && !isRoot) {\n\t\t\t// If there is a parentTreeViewItem, it means that the currentTreeViewItem was a dynamic one, so we add it to the parent\n\t\t\taddElement(treeViewItem, parentTreeViewItem);\n\t\t}\n\n\t\tconst whenDynamicEmbeddedViewFound = (dynamicLView: LView) => {\n\t\t\ttraverseTree(\n\t\t\t\tdynamicLView,\n\t\t\t\tfalse,\n\t\t\t\ttreeViewItem.lView[HOST] ? treeViewItem : parentTreeViewItem\n\t\t\t);\n\t\t};\n\n\t\tloopDynamicEmbeddedViews({\n\t\t\tlView,\n\t\t\twork: whenDynamicEmbeddedViewFound\n\t\t});\n\n\t\tconst whenChildComponentFound = (childLView: LView) => {\n\t\t\tif (!childLView[HOST][DEVTOOLS_IDENTIFIER]) {\n\t\t\t\tchildLView[HOST][DEVTOOLS_IDENTIFIER] = uuid();\n\t\t\t}\n\t\t\ttraverseTree(\n\t\t\t\tchildLView,\n\t\t\t\tfalse,\n\t\t\t\ttreeViewItem.lView[HOST] ? treeViewItem : parentTreeViewItem\n\t\t\t);\n\t\t};\n\n\t\tloopChildComponents({ lView, work: whenChildComponentFound });\n\n\t\tif (isRoot) {\n\t\t\treturn accumulator ? accumulator : treeViewItem;\n\t\t}\n\t};\n};\n\nexport function transformTreeToInstructions(\n\tinputTreeViewItem: SerializedTreeViewItem\n) {\n\tconst instructions = new Map<string, SerializedTreeViewItem>();\n\n\tconst walkTree = (treeViewItem: SerializedTreeViewItem) => {\n\t\tinstructions.set(treeViewItem.uuid, treeViewItem);\n\t\ttreeViewItem.children.forEach(childTreeViewItem =>\n\t\t\twalkTree(childTreeViewItem)\n\t\t);\n\t};\n\n\twalkTree(inputTreeViewItem);\n\n\treturn instructions;\n}\n\n// Because of dynamicEmbeddedViews and because we need to be able to walk the tree, some elements are added as parents which aren't\n// components, we need to filter those out\nexport function getRealParent(treeViewItem: TreeViewItem) {\n\tif (treeViewItem.lView[HOST]) {\n\t\treturn treeViewItem;\n\t} else {\n\t\treturn getRealParent(treeViewItem.parent);\n\t}\n}\n"]}