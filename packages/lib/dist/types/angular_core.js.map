{"version":3,"file":"angular_core.js","sourceRoot":"","sources":["../../src/types/angular_core.ts"],"names":[],"mappings":";;AAQa,QAAA,qBAAqB,GAAG,eAAe,CAAC;AAErD,yEAAyE;AACzE,mDAAmD;AACnD,wEAAwE;AAC3D,QAAA,IAAI,GAAG,CAAC,CAAC;AACT,QAAA,KAAK,GAAG,CAAC,CAAC;AACV,QAAA,KAAK,GAAG,CAAC,CAAC;AACV,QAAA,MAAM,GAAG,CAAC,CAAC;AACX,QAAA,IAAI,GAAG,CAAC,CAAC;AACT,QAAA,OAAO,GAAG,CAAC,CAAC;AACZ,QAAA,UAAU,GAAG,EAAE,CAAC;AAChB,QAAA,UAAU,GAAG,EAAE,CAAC;AAChB,QAAA,gBAAgB,GAAG,EAAE,CAAC;AAEnC;;;;GAIG;AACH;;;;GAIG;AACU,QAAA,YAAY,GAAG,CAAC,CAAC;AAC9B,8DAA8D;AAC9D,gFAAgF;AACnE,QAAA,MAAM,GAAG,CAAC,CAAC;AACX,QAAA,SAAS,GAAG,CAAC,CAAC;AAE3B;;;;;GAKG;AACU,QAAA,uBAAuB,GAAG,CAAC,CAAC;AAE5B,QAAA,aAAa,GAAG,EAAE,CAAC;AAEhC;;;;GAIG;AACU,QAAA,IAAI,GAAG,CAAC,CAAC","sourcesContent":["export interface RootContext {\n\t/**\n\t * RootComponents - The components that were instantiated by the call to\n\t * {@link renderComponent}.\n\t */\n\tcomponents: {}[];\n}\n\nexport const MONKEY_PATCH_KEY_NAME = '__ngContext__';\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const HOST = 0;\nexport const TVIEW = 1;\nexport const FLAGS = 2;\nexport const PARENT = 3;\nexport const NEXT = 4;\nexport const CONTEXT = 9;\nexport const CHILD_HEAD = 14;\nexport const CHILD_TAIL = 15;\nexport const DECLARATION_VIEW = 17;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport const ACTIVE_INDEX = 2;\n// PARENT, NEXT, QUERIES and T_HOST are indices 3, 4, 5 and 6.\n// As we already have these constants in LView, we don't need to re-create them.\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 9;\n\nexport const HEADER_OFFSET = 20;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n\nexport interface TView {\n\ttemplate: Function | null;\n\n\tcomponents: number[] | null;\n}\n\nexport interface LContainer extends Array<any> {}\n\nexport interface LView extends Array<any> {\n\t/**\n\t * The host node for this LView instance, if this is a component view.\n\t *\n\t * If this is an embedded view, HOST will be null.\n\t *\n\t * If the component uses host bindings for styling that the `RElement` will be wrapped with\n\t * `StylingContext`.\n\t */\n\t[HOST]: any;\n\n\t/**\n\t * The static data for this view. We need a reference to this so we can easily walk up the\n\t * node tree in DI and get the TView.data array associated with a node (where the\n\t * directive defs are stored).\n\t */\n\treadonly [TVIEW]: TView;\n\n\t[PARENT]: LView | LContainer | null;\n\n\t/**\n\t *\n\t * The next sibling LView or LContainer.\n\t *\n\t * Allows us to propagate between sibling view states that aren't in the same\n\t * container. Embedded views already have a node.next, but it is only set for\n\t * views in the same container. We need a way to link component views and views\n\t * across containers as well.\n\t */\n\t[NEXT]: LView | LContainer | null;\n\n\t/**\n\t * - For dynamic views, this is the context with which to render the template (e.g.\n\t *   `NgForContext`), or `{}` if not defined explicitly.\n\t * - For root view of the root component the context contains change detection data.\n\t * - For non-root components, the context is the component instance,\n\t * - For inline views, the context is null.\n\t */\n\t[CONTEXT]: {} | RootContext | null;\n\n\t/**\n\t * Reference to the first LView or LContainer beneath this LView in\n\t * the hierarchy.\n\t *\n\t * Necessary to store this so views can traverse through their nested views\n\t * to remove listeners and call onDestroy callbacks.\n\t */\n\t[CHILD_HEAD]: LView | LContainer | null;\n}\n\nexport interface LContext {\n\t/**\n\t * The component's parent view data.\n\t */\n\tlView: LView;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n\t/** The state of the init phase on the first 2 bits */\n\tInitPhaseStateIncrementer = 0b00000000001,\n\tInitPhaseStateMask = 0b00000000011,\n\n\t/**\n\t * Whether or not the view is in creationMode.\n\t *\n\t * This must be stored in the view rather than using `data` as a marker so that\n\t * we can properly support embedded views. Otherwise, when exiting a child view\n\t * back into the parent view, `data` will be defined and `creationMode` will be\n\t * improperly reported as false.\n\t */\n\tCreationMode = 0b00000000100,\n\n\t/**\n\t * Whether or not this LView instance is on its first processing pass.\n\t *\n\t * An LView instance is considered to be on its \"first pass\" until it\n\t * has completed one creation mode run and one update mode run. At this\n\t * time, the flag is turned off.\n\t */\n\tFirstLViewPass = 0b00000001000,\n\n\t/** Whether this view has default change detection strategy (checks always) or onPush */\n\tCheckAlways = 0b00000010000,\n\n\t/**\n\t * Whether or not manual change detection is turned on for onPush components.\n\t *\n\t * This is a special mode that only marks components dirty in two cases:\n\t * 1) There has been a change to an @Input property\n\t * 2) `markDirty()` has been called manually by the user\n\t *\n\t * Note that in this mode, the firing of events does NOT mark components\n\t * dirty automatically.\n\t *\n\t * Manual mode is turned off by default for backwards compatibility, as events\n\t * automatically mark OnPush components dirty in View Engine.\n\t *\n\t * TODO: Add a public API to ChangeDetectionStrategy to turn this mode on\n\t */\n\tManualOnPush = 0b00000100000,\n\n\t/** Whether or not this view is currently dirty (needing check) */\n\tDirty = 0b000001000000,\n\n\t/** Whether or not this view is currently attached to change detection tree. */\n\tAttached = 0b000010000000,\n\n\t/** Whether or not this view is destroyed. */\n\tDestroyed = 0b000100000000,\n\n\t/** Whether or not this view is the root view */\n\tIsRoot = 0b001000000000,\n\n\t/**\n\t * Index of the current init phase on last 22 bits\n\t */\n\tIndexWithinInitPhaseIncrementer = 0b010000000000,\n\tIndexWithinInitPhaseShift = 10,\n\tIndexWithinInitPhaseReset = 0b001111111111\n}\n"]}