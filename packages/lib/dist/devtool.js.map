{"version":3,"file":"devtool.js","sourceRoot":"","sources":["../src/devtool.ts"],"names":[],"mappings":"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","sourcesContent":["import { HOST, LView, RootContext, TView, TVIEW } from './types/angular_core';\nimport { createMeasurement, Tracer } from './visualisation/tracing';\nimport { LViewStateManager } from './l-view-state-manager';\nimport { mapToObject, readPatchedLView } from './util';\nimport {\n\tloopChildComponents,\n\tloopDynamicEmbeddedViews,\n\ttransformTreeToInstructions,\n\ttraverseTreeAndCreateTreeStructure\n} from './tree-traversal';\nimport { scheduleOutsideOfZone } from './zone-handler';\nimport { GraphRender } from './visualisation/graph';\nimport * as uuid from 'uuid';\nimport { DEVTOOLS_IDENTIFIER } from './constants';\nimport { serialiseTreeViewItem } from './tree-view-builder';\n\nconst tracer = new Tracer();\nconst treeGraph = new GraphRender('liveTree');\nconst lViewStateManager = new LViewStateManager();\n\nlet patchedTemplateFns: Array<{ tView: TView, origTemplate: Function }> = [];\n\n// In dev mode, there will be two cycles. The second cycle is purely used for making sure the unidirectional data flow is followed and\n// should not be visualised. We opt to not track this second cycle.\nlet cdCycleCountInCurrentLoop = 0;\nconst monkeyPatchTemplate = (tView: TView, rootLView?: LView) => {\n\tif ((tView.template as any).__template_patched__) {\n\t\treturn;\n\t}\n\tconst origTemplate = tView.template;\n\ttView.template = function (...args) {\n\t\tconsole.log(rootLView, args[0], cdCycleCountInCurrentLoop);\n\t\tif (rootLView) {\n\t\t\tcdCycleCountInCurrentLoop++;\n\t\t}\n\t\t// Mode will be 1 for creation and 2 for update\n\t\tconst mode = args[0];\n\t\t// Don't get the next lView if we are in creation mode as it will be called immediately in update mode\n\t\tif (mode === 1 || cdCycleCountInCurrentLoop !== 1) {\n\t\t\tconsole.log('short circuiting');\n\t\t\torigTemplate(...args);\n\t\t\treturn;\n\t\t}\n\t\tif (rootLView) {\n\t\t\t// If we have the rootLView, it means that we have started a new cycle\n\t\t\tlViewStateManager.resetState();\n\t\t\tconsole.log('scheduled!');\n\t\t\tscheduleOutsideOfZone(() => {\n\t\t\t\tcdCycleCountInCurrentLoop = 0;\n\t\t\t\tconst updatedTree = serialiseTreeViewItem(lViewStateManager.getTree());\n\t\t\t\tconst entireTree = serialiseTreeViewItem(\n\t\t\t\t\ttraverseTreeAndCreateTreeStructure(rootLView, true)\n\t\t\t\t);\n\t\t\t\tconst updatedTreeAsInstructions = transformTreeToInstructions(\n\t\t\t\t\tupdatedTree\n\t\t\t\t);\n\t\t\t\t// treeGraph.setUpdates(entireTree, updatedTreeAsInstructions);\n\t\t\t\t// renderTree('lastUpdatedTree', entireTree, updatedTreeAsInstructions);\n\t\t\t\t// const events = new CustomEvent('PassToBackground', {detail: message});\n\n\t\t\t\t// sendMessage({\n\t\t\t\t// \ttype: 'ENTIRE_TREE',\n\t\t\t\t// \tpayload: {entireTree, instructions: mapToObject(updatedTreeAsInstructions)}\n\t\t\t\t// });\n\t\t\t\t// sendMessage({\n\t\t\t\t// \ttype: 'UPDATED_TREE',\n\t\t\t\t// \tpayload: {updatedTree}\n\t\t\t\t// });\n\t\t\t\t// window.postMessage('whatever', '*');\n\t\t\t\twindow.dispatchEvent(new CustomEvent('ContentScriptEvent', {\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\ttype: 'ENTIRE_TREE',\n\t\t\t\t\t\tpayload: {entireTree, instructions: mapToObject(updatedTreeAsInstructions)}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t\tconsole.log('updatedTree', updatedTree);\n\t\t\t\twindow.dispatchEvent(new CustomEvent('ContentScriptEvent', {\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\ttype: 'UPDATED_TREE',\n\t\t\t\t\t\tpayload: {updatedTree}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t}\n\t\t// Set the pointer to the next lView\n\t\tlViewStateManager.getNextLView(null, rootLView);\n\t\tconst currentLView = lViewStateManager.predictedNextLView;\n\t\t// console.log('CD for ', currentLView[HOST].tagName);\n\n\t\tif (!currentLView[HOST][DEVTOOLS_IDENTIFIER]) {\n\t\t\tcurrentLView[HOST][DEVTOOLS_IDENTIFIER] = uuid();\n\t\t}\n\t\torigTemplate(...args);\n\n\t\t// After executing the template, we need to check if components were added\n\t\t// TODO: check if we need to check child components again (prolly dynamicEmbeddedViews are enough)\n\t\tmonkeyPatchDirectChildren(currentLView);\n\n\t\t// Lastly, we need to update the Tracer to show a box. This has to be done in a timeout as the view dimensions have not\n\t\t// been updated at this point yet.\n\t\tscheduleOutsideOfZone(() => {\n\t\t\t\t// console.log(`Tracing for ${currentLView[HOST].tagName}`, currentLView[HOST]);\n\t\t\t\ttracer.present(\n\t\t\t\t\tcurrentLView[HOST][DEVTOOLS_IDENTIFIER],\n\t\t\t\t\tcurrentLView[HOST].tagName,\n\t\t\t\t\tcreateMeasurement(currentLView[0].getBoundingClientRect())\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t};\n\t(tView.template as any).__template_patched__ = true;\n\n\tpatchedTemplateFns.push({origTemplate: origTemplate, tView});\n};\n\nexport function monkeyPatchDirectChildren(lView: LView, isRoot = false) {\n\t// Patch direct child components\n\tlet whenChildComponentFound;\n\tif (isRoot) {\n\t\twhenChildComponentFound = (childLView: LView) =>\n\t\t\tmonkeyPatchTemplate(childLView[TVIEW], childLView);\n\t} else {\n\t\twhenChildComponentFound = (childLView: LView) =>\n\t\t\tmonkeyPatchTemplate(childLView[TVIEW]);\n\t}\n\tloopChildComponents({lView, work: whenChildComponentFound});\n\t// Find components in the dynamicEmbeddedViews to patch\n\tconst whenDynamicEmbeddedViewFound = (dynamicLView: LView) => {\n\t\tif (dynamicLView[HOST]) {\n\t\t\tmonkeyPatchTemplate(dynamicLView[TVIEW]);\n\t\t}\n\t\tmonkeyPatchDirectChildren(dynamicLView);\n\t};\n\tloopDynamicEmbeddedViews({lView, work: whenDynamicEmbeddedViewFound});\n}\n\nexport function monkeyPatchRootNode(rootContext: RootContext) {\n\tfor (let i = 0; i < rootContext.components.length; i++) {\n\t\tconst rootComponent = rootContext.components[i];\n\t\tconst rootComponentLView = readPatchedLView(rootComponent);\n\t\tmonkeyPatchDirectChildren(rootComponentLView, true);\n\t}\n}\n\nexport function undoMonkeyPatch() {\n\tpatchedTemplateFns.forEach(data => {\n\t\tdata.tView.template = data.origTemplate;\n\t});\n\tpatchedTemplateFns = [];\n}\n"]}